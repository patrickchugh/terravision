BEGIN{
  double bbMinX, bbMinY, bbMaxX, bbMaxY, lpX, lpY, lpMinX, lpMaxY, newX, newY, centerX;
  double fudgeX, fudgeY;
  double cloudMinX, cloudMinY, cloudMaxX, cloudMaxY, cloudCenterX;
  double clusterMinX, clusterMinY, clusterMaxX, clusterMaxY, clusterCenterX;
  double labelX, labelY;
  double topMostY, bottomMostY;
  string fld[int];
  node_t n;

  // recursive routine, processing from the top (root) down
  graph_t labelShift (graph_t Gr) {
    graph_t thisG;

    // First recurse into subgraphs
    for (thisG = fstsubg(Gr); thisG; thisG=nxtsubg(thisG)) {
          thisG = labelShift(thisG);
    }

    if (match(Gr.name,"cluster")==0 ){
      // Check for main cloud provider group using _cloudgroup flag
      if (hasAttr(Gr, "_cloudgroup") && Gr._cloudgroup=="1"){
        sscanf (Gr.bb, "%lf,%lf,%lf,%lf", &cloudMinX, &cloudMinY, &cloudMaxX, &cloudMaxY);
        cloudCenterX = (cloudMinX + cloudMaxX) / 2.0;
      }

      // Position cluster label nodes within this cluster
      sscanf (Gr.bb, "%lf,%lf,%lf,%lf", &clusterMinX, &clusterMinY, &clusterMaxX, &clusterMaxY);
      clusterCenterX = (clusterMinX + clusterMaxX) / 2.0;

      for (n = fstnode(Gr); n; n = nxtnode_sg(Gr, n)) {
        if (hasAttr(n, "_clusterlabel") && n._clusterlabel == "1") {
          // Only position label nodes that belong to THIS cluster (not nested subgraphs)
          if (hasAttr(n, "_clusterid") && hasAttr(n, "_labelposition")) {
            if (n._clusterid == Gr.name) {
              // Calculate position based on label_position attribute
              // Position inside cluster at bottom with X offset to prevent neato from moving them
              if (n._labelposition == "bottom-left") {
                // Different X offsets for different cluster types
                labelY = clusterMinY + 40.0;
                if (hasAttr(n, "_clustertype") && n._clustertype == "SubnetGroup") {
                  labelX = clusterMinX + 50.0;  // Smaller offset for Subnets (icon at corner)
                } else if (hasAttr(n, "_clustertype") && n._clustertype == "AZUREGroup") {
                  labelX = clusterMinX + 200.0;  // medium offset for Azure Cloud (outermost container)
                  labelY = clusterMinY -20;
                } else {
                  labelX = clusterMinX + 70.0;  // Standard offset for Resource Groups
                }

              } else if (n._labelposition == "bottom-right") {
                labelX = clusterMaxX - 50.0;  // Shifted left from right edge
                labelY = clusterMinY + 45.0;
              } else if (n._labelposition == "bottom-center") {
                labelX = clusterCenterX;
                labelY = clusterMinY + 50.0;
              }

              // Pin the node position
              n.pos = sprintf("%.1f,%.1f!", labelX, labelY);
            }
          }
        }
      }

      // Handle top positioning for AWS clusters (original logic)
      if (hasAttr(Gr, "_shift") && Gr._shift!="" && Gr._shift!="0"){
        fudgeX=2.;  // aim for just inside periphery  - increase to shift left
        fudgeY=1.;  // aim for just inside periphery  - increase to shift up
      if (index(Gr._shift,",")>0){
        split(Gr._shift,fld,",");
        fudgeX=(double)fld[0];
        fudgeY=(double)fld[1];
      }
      sscanf (Gr.bb, "%lf,%lf,%lf,%lf", &bbMinX, &bbMinY, &bbMaxX, &bbMaxY);
      lpX=xOf(Gr.lp);
      lpY=yOf(Gr.lp);
      lpMinX=lpX-((Gr.lwidth*72.)/2.);
      lpMaxY=lpY+((Gr.lheight*72.)/2.);
      //print("  // bb: ", Gr.bb, "  lpMinX: ", lpMinX, "  lpMaxY: ", lpMaxY);
      Gr._oldlp=Gr.lp;
      newX=lpX-(lpMinX-bbMinX)-fudgeX;
      newY=lpY+(bbMaxY-lpMaxY)+fudgeY;
      Gr.lp=sprintf("%.1f,%.1f", newX, newY);
      }
    }
    return Gr;
  } // end of labelShift
}
BEG_G{
  double nodeY;
  topMostY = 0;
  bottomMostY = 999999.0;

  labelShift($G);

  // Center edge nodes (CDN, API GW, etc.) among their targets so ortho edges
  // fan out in multiple directions instead of all routing in parallel.
  // Only nodes tagged with _edgenode="1" by drawing.py are candidates.
  edge_t e;
  node_t src, tgt;
  int fanoutCount;
  double sumX, avgX, srcX, srcY;
  int centeredCount;
  centeredCount = 0;

  for (src = fstnode($G); src; src = nxtnode(src)) {
    if (!hasAttr(src, "_edgenode") || src._edgenode != "1") continue;

    fanoutCount = 0;
    sumX = 0.0;
    for (e = fstout(src); e; e = nxtout(e)) {
      tgt = e.head;
      if (hasAttr(tgt, "_titlenode") && tgt._titlenode == "1") continue;
      if (hasAttr(tgt, "_footernode") && tgt._footernode == "1") continue;
      if (hasAttr(tgt, "_clusterlabel") && tgt._clusterlabel == "1") continue;
      sumX = sumX + xOf(tgt.pos);
      fanoutCount = fanoutCount + 1;
    }

    if (fanoutCount > 3) {
      avgX = sumX / (double)fanoutCount;
      srcX = xOf(src.pos);
      srcY = yOf(src.pos);
      // Only center if significantly off-center from targets (>1000pt ~14in)
      double xDist = srcX - avgX;
      if (xDist < 0) xDist = -xDist;
      if (xDist > 1000.0) {
        // Clamp avgX within cloud group bounds
        if (cloudMaxX > 0) {
          if (avgX < cloudMinX + 50.0) avgX = cloudMinX + 50.0;
          if (avgX > cloudMaxX - 50.0) avgX = cloudMaxX - 50.0;
        }

        // Position just inside cloud group top â€” well above VPC/sub-clusters
        src.pos = sprintf("%.1f,%.1f!", avgX, cloudMaxY - 60.0);
        // Clear edge positions so neato -n2 re-routes them from the new location
        edge_t oe;
        for (oe = fstout(src); oe; oe = nxtout(oe)) {
          oe.pos = "";
        }
        for (oe = fstin(src); oe; oe = nxtin(oe)) {
          oe.pos = "";
        }
        centeredCount = centeredCount + 1;
      }
    }
  }

  // Find topmost and bottommost node positions (including outer nodes)
  for (n = fstnode($G); n; n = nxtnode(n)) {
    if (hasAttr(n, "_titlenode") && n._titlenode == "1") continue;
    if (hasAttr(n, "_footernode") && n._footernode == "1") continue;
    nodeY = yOf(n.pos);
    if (nodeY > topMostY) topMostY = nodeY;
    if (nodeY < bottomMostY) bottomMostY = nodeY;
  }

  // Use higher of cloudMaxY or topMostY
  if (cloudMaxY > topMostY) topMostY = cloudMaxY;
  // Use lower of cloudMinY or bottomMostY
  if (cloudMinY < bottomMostY) bottomMostY = cloudMinY;
}
END_G{
  double gbbMinX, gbbMinY, gbbMaxX, gbbMaxY, gcenterX, glpY;
  // Center root graph label at the END after all processing
  sscanf ($G.bb, "%lf,%lf,%lf,%lf", &gbbMinX, &gbbMinY, &gbbMaxX, &gbbMaxY);
  gcenterX = (gbbMinX + gbbMaxX) / 2.0;
  glpY = yOf($G.lp);
  $G.lp = sprintf("%.1f,%.1f", gcenterX, glpY);
}
N[_titlenode=="1"]{
  pos=sprintf("%.0f,%.0f!", cloudCenterX, topMostY + 200);
}
N[_footernode=="1"]{
  pos=sprintf("%.0f,%.0f!", cloudCenterX, bottomMostY - 180);
}
